<!DOCTYPE HTML>
<html>
	<head>
		<title>Synthesis Astrology V2</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
			pre {
				background-color: #2a2f43;
				border-radius: 4px;
				border: solid 1px rgba(255, 255, 255, 0.25);
				font-family: "Courier New", monospace;
				padding: 1.5em;
				white-space: pre-wrap;
				word-break: break-word;
				font-size: 14px;
			}
		
			#gemini-output {
				font-family: "Source Sans Pro", sans-serif; /* Match the theme's font */
				font-size: 1rem;
				line-height: 1.65;
				color: #ffffff; /* Brighter text for reading */
			}
		
			.time-inputs {
				display: flex;
				gap: 1rem;
				align-items: flex-end;
			}
			
			.time-note {
				font-size: 0.8rem;
			}
		
			.results-container .major {
				margin-bottom: 2rem;
			}
			
			/* Chart Wheel SVG styles */
			#chart-wheel-svg { width: 100%; height: auto; aspect-ratio: 1 / 1; }
			.wheel-circle { stroke: rgba(255, 255, 255, 0.25); stroke-width: 2; fill: none; }
			.zodiac-divider { stroke: rgba(255, 255, 255, 0.25); stroke-width: 1; }
			.house-cusp { stroke: #ffffff; stroke-width: 1.5; }
			.house-cusp.major { stroke-width: 3; }
			.house-number { fill: #ffffff; font-size: 24px; text-anchor: middle; dominant-baseline: middle; opacity: 0.8;}
			.zodiac-glyph { fill: #ffffff; font-size: 30px; text-anchor: middle; dominant-baseline: middle; }
			.planet-glyph { fill: #ffffff; font-size: 35px; text-anchor: middle; dominant-baseline: middle; }
			.planet-retrograde { fill: #ffffff; font-size: 20px; }
			.aspect-line { stroke-width: 1.5; opacity: 0.6; }
			.aspect-conjunction { stroke: #34d399; }
			.aspect-opposition, .aspect-square { stroke: #f43f5e; }
			.aspect-trine, .aspect-sextile { stroke: #38bdf8; }
			.aspect-quincunx, .aspect-semisextile, .aspect-semisquare, .aspect-sesquiquadrate, .aspect-quintile, .aspect-biquintile { stroke: rgba(255, 255, 255, 0.25); stroke-dasharray: 4 4; }
		</style>
	</head>
	<body class="is-preload">

		<div id="wrapper">

				<header id="header" class="alt">
						<a href="index.html" class="logo"><strong>Synthesis</strong> <span>Astrology</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<nav id="menu">
						<ul class="links">
							<li><a href="index.html">Home</a></li>
						</ul>
					</nav>

				<section id="banner" class="major">
						<div class="inner">
							<header class="major">
								<h1>Synthesis Astrology V2</h1>
							</header>
							<div class="content">
								<p>Welcome to a highly advanced astrology calculator designed for public use. Explore your complete cosmic blueprint below.</p>
							</div>
						</div>
					</section>

				<div id="main">

						<section id="form-section">
								<div class="inner">
									<header class="major">
										<h2>Generate Your Chart</h2>
									</header>
									<form id="chartForm">
										<div class="fields">
											<div class="field half">
												<label for="fullName">Full Birth Name</label>
												<input type="text" id="fullName" name="fullName" required placeholder="Including middle name for numerology">
											</div>
											<div class="field half">
												<label for="birthDate">Birth Date</label>
												<input type="text" id="birthDate" name="birthDate" required placeholder="MM/DD/YYYY">
											</div>
											<div class="field">
												<label for="location">Birth Location</label>
												<input type="text" id="location" name="location" required placeholder="City, State, Country">
											</div>
											<div class="field half">
												<p class="time-note">For the most accurate results, please enter your exact birth time.</p>
												<input type="checkbox" id="unknownTime" name="unknownTime">
												<label for="unknownTime">I don't know my birth time</label>
											</div>
											<div class="field half time-inputs-container">
												<div class="time-inputs">
													<div>
														<label for="hour">Hour</label>
														<input type="number" id="hour" name="hour" required min="1" max="12" style="width: 80px;">
													</div>
													<div>
														<label for="minute">Minute</label>
														<input type="number" id="minute" name="minute" required min="0" max="59" style="width: 80px;">
													</div>
													<div>
														<label for="ampm">AM/PM</label>
														<select id="ampm" name="ampm">
															<option value="am">AM</option>
															<option value="pm">PM</option>
														</select>
													</div>
												</div>
											</div>
										</div>
										<ul class="actions">
											<li><button type="submit" id="submitBtn" class="primary">Calculate Chart</button></li>
										</ul>
									</form>
								</div>
							</section>

						<section id="results" class="results-container" style="display: none;">
								<div class="inner">
									<div id="wheel-title" class="result-section">
										<header class="major"><h2 style="text-align: left;">Chart Wheel</h2></header>
										<div id="chart-wheel-container"><svg id="chart-wheel-svg" viewBox="-100 -100 1200 1200"></svg></div>
									</div>
							
									<div id="gemini-title" class="result-section">
										<header class="major"><h2 style="text-align: left;">AI Astrological Synthesis</h2></header>
										<div id="gemini-output" class="content"></div>
									</div>
							
									<div id="results-title" class="result-section">
										<header class="major"><h2 style="text-align: left;">Full Report</h2></header>
										<pre id="output"></pre>
									</div>
							
									<div id="legend-title" class="result-section">
										<header class="major"><h2 style="text-align: left;">Glyph Legend</h2></header>
										<pre id="glyph-legend"></pre>
									</div>
								</div>
							</section>

					</div>

				<footer id="footer">
						<div class="inner">
							<ul class="copyright">
								<li>&copy; Synthesis Astrology</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
            <script>
				const AstrologyCalculator = {
					API_URLS: {
						calculate: "https://true-sidereal-api.onrender.com/calculate_chart",
						reading: "https://true-sidereal-api.onrender.com/generate_reading"
					},
					SVG_NS: "http://www.w3.org/2000/svg",
					ZODIAC_GLYPHS: {'Aries':'♈︎','Taurus':'♉︎','Gemini':'♊︎','Cancer':'♋︎','Leo':'♌︎','Virgo':'♍︎','Libra':'♎︎','Scorpio':'♏︎','Ophiuchus':'⛎︎','Sagittarius':'♐︎','Capricorn':'♑︎','Aquarius':'♒︎','Pisces':'♓︎'},
					PLANET_GLYPHS: {'Sun':'☉','Moon':'☽','Mercury':'☿','Venus':'♀','Mars':'♂','Jupiter':'♃','Saturn':'♄','Uranus':'♅','Neptune':'♆','Pluto':'♇','Chiron':'⚷','True Node':'☊','South Node':'☋','Ascendant':'AC','Midheaven (MC)':'MC','Descendant':'DC','Imum Coeli (IC)':'IC'},
			
					form: null, submitBtn: null, outputEl: null, geminiTitle: null, geminiOutput: null,
					resultsTitle: null, wheelTitle: null, wheelContainer: null, wheelSvg: null,
					legendTitle: null, legendEl: null,
					
					init() {
						this.cacheDOMElements();
						this.addEventListeners();
						this.populateGlyphLegend();
					},
			
					cacheDOMElements() {
						this.form = document.getElementById("chartForm");
						this.submitBtn = document.getElementById("submitBtn");
						this.outputEl = document.getElementById("output");
						this.geminiTitle = document.getElementById('gemini-title').parentElement; // Get parent for visibility
						this.geminiOutput = document.getElementById('gemini-output');
						this.resultsTitle = document.getElementById('results-title').parentElement;
						this.wheelTitle = document.getElementById('wheel-title').parentElement;
						this.legendTitle = document.getElementById('legend-title').parentElement;
						this.wheelSvg = document.getElementById('chart-wheel-svg');
						this.legendEl = document.getElementById('glyph-legend');
						this.resultsContainer = document.getElementById('results');
					},
					
					addEventListeners() {
						const unknownTimeCheckbox = document.getElementById('unknownTime');
						const hourInput = document.getElementById('hour');
						const minuteInput = document.getElementById('minute');
						const ampmSelect = document.getElementById('ampm');
						
						unknownTimeCheckbox.addEventListener('change', function() {
							const isChecked = this.checked;
							hourInput.disabled = isChecked; minuteInput.disabled = isChecked; ampmSelect.disabled = isChecked;
							if (isChecked) { hourInput.value = '12'; minuteInput.value = '00'; ampmSelect.value = 'pm'; }
						});
						this.form.addEventListener("submit", (e) => this.handleFormSubmit(e));
					},
			
					async handleFormSubmit(e) {
						e.preventDefault();
						this.setLoadingState(true);
			
						try {
							const chartData = await this.fetchChartData();
							this.displayInitialResults(chartData);
							this.fetchAndDisplayAIReading(chartData);
						} catch (err) {
							this.resultsContainer.style.display = 'block';
							this.resultsTitle.style.display = 'block';
							this.outputEl.innerText = "Error: " + err.message;
						} finally {
							this.setLoadingState(false);
						}
					},
					
					async fetchChartData() {
						const birthDateParts = this.form.querySelector("[name='birthDate']").value.split('/');
						if (birthDateParts.length !== 3) throw new Error("Please enter the date in MM/DD/YYYY format.");
						const [month, day, year] = birthDateParts.map(s => parseInt(s));
						let hour = parseInt(this.form.querySelector("[name='hour']").value);
						const ampm = this.form.querySelector("[name='ampm']").value;
						if (ampm === 'pm' && hour < 12) hour += 12;
						if (ampm === 'am' && hour === 12) hour = 0;
			
						const apiRes = await fetch(this.API_URLS.calculate, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({
								full_name: this.form.querySelector("[name='fullName']").value,
								year, month, day, hour,
								minute: parseInt(this.form.querySelector("[name='minute']").value),
								location: this.form.querySelector("[name='location']").value,
								unknown_time: this.form.querySelector("[name='unknownTime']").checked
							}),
						});
			
						if (!apiRes.ok) {
							const errData = await apiRes.json();
							throw new Error(`API Error ${apiRes.status}: ${errData.detail}`);
						}
						return await apiRes.json();
					},
			
					async fetchAndDisplayAIReading(chartData) {
						try {
							const readingRes = await fetch(this.API_URLS.reading, {
								method: "POST",
								headers: { "Content-Type": "application/json" },
								body: JSON.stringify({
									chart_data: chartData,
									unknown_time: chartData.unknown_time
								})
							});
			
							if (!readingRes.ok) throw new Error('AI Reading service failed.');
			
							const readingResult = await readingRes.json();
							this.geminiOutput.innerText = readingResult.gemini_reading || "The AI reading could not be generated at this time.";
						} catch (err) {
							this.geminiOutput.innerText = "Error: The AI reading is currently unavailable. " + err.message;
						}
					},
			
					setLoadingState(isLoading) {
						this.submitBtn.disabled = isLoading;
						this.submitBtn.innerText = isLoading ? "Calculating..." : "Calculate Chart";
			
						if (isLoading) {
							this.resultsContainer.style.display = 'none';
						}
					},
			
					displayInitialResults(chartData) {
						this.resultsContainer.style.display = 'block';

						this.geminiTitle.style.display = 'block';
						this.geminiOutput.innerText = "Generating AI Synthesis...";
						
						this.resultsTitle.style.display = 'block';
						this.renderTextResults(chartData);
			
						if (!chartData.unknown_time) {
							this.wheelTitle.style.display = 'block';
							this.legendTitle.style.display = 'block';
							this.drawChartWheel(chartData);
						} else {
							this.wheelTitle.style.display = 'none';
							this.legendTitle.style.display = 'none';
						}
					},
			
					renderTextResults(res) {
						let out = `=== TRUE SIDEREAL CHART: ${res.name} ===\n`;
						out += `- UTC Date & Time: ${res.utc_datetime}${res.unknown_time ? ' (Noon Estimate)' : ''}\n`;
						out += `- Location: ${res.location}\n`;
						out += `- Day/Night Determination: ${res.day_night_status}\n\n`;
						
						out += `--- CHINESE ZODIAC ---\n`;
						out += `- Your sign is the ${res.chinese_zodiac}\n\n`;
			
						out += `--- NUMEROLOGY REPORT ---\n`;
						if (res.numerology_analysis) {
							out += `- Life Path Number: ${res.numerology_analysis.life_path_number}\n`;
							out += `- Day Number: ${res.numerology_analysis.day_number}\n`;
							if (res.numerology_analysis.name_numerology) {
								out += `\n-- NAME NUMEROLOGY --\n`;
								out += `- Expression (Destiny) Number: ${res.numerology_analysis.name_numerology.expression_number}\n`;
								out += `- Soul Urge Number: ${res.numerology_analysis.name_numerology.soul_urge_number}\n`;
								out += `- Personality Number: ${res.numerology_analysis.name_numerology.personality_number}\n`;
							}
						}
						
						out += `\n-- SIDEREAL CHART ANALYSIS --\n`;
						out += `- Chart Ruler: ${res.sidereal_chart_analysis.chart_ruler}\n`;
						out += `- Dominant Sign: ${res.sidereal_chart_analysis.dominant_sign}\n`;
						out += `- Dominant Element: ${res.sidereal_chart_analysis.dominant_element}\n`;
						out += `- Dominant Modality: ${res.sidereal_chart_analysis.dominant_modality}\n`;
						out += `- Dominant Planet: ${res.sidereal_chart_analysis.dominant_planet}\n\n`;
						
						out += `--- MAJOR POSITIONS ---\n`;
						res.sidereal_major_positions.forEach(p => {
							let line = `- ${p.name}: ${p.position}`;
							if (!['Ascendant', 'Descendant', 'Midheaven (MC)', 'Imum Coeli (IC)', 'South Node'].includes(p.name)) {
								line += ` (${p.percentage}%)`;
							}
							if (p.retrograde) { line += " (Rx)"; }
							if (p.house_info) { line += ` ${p.house_info}`; }
							out += `${line}\n`;
						});
			
						if (res.sidereal_retrogrades && res.sidereal_retrogrades.length > 0) {
							out += `\n--- RETROGRADE PLANETS (Energy turned inward) ---\n`;
							res.sidereal_retrogrades.forEach(p => {
								out += `- ${p.name}\n`;
							});
						}
			
						out += `\n--- MAJOR ASPECTS (ranked by influence score) ---\n`;
						res.sidereal_aspects.forEach(a => { out += `- ${a.p1_name} ${a.type} ${a.p2_name} (orb ${a.orb}, score ${a.score})\n`; });
						out += `\n--- ASPECT PATTERNS ---\n`;
						(res.sidereal_aspect_patterns && res.sidereal_aspect_patterns.length > 0) ? res.sidereal_aspect_patterns.forEach(p => { out += `- ${p}\n`; }) : out += "- No major aspect patterns detected.\n";
						if (!res.unknown_time) {
							out += `\n--- ADDITIONAL POINTS & ANGLES ---\n`;
							res.sidereal_additional_points.forEach(p => { 
								let line = `- ${p.name}: ${p.info}`;
								if (p.retrograde) { line += " (Rx)"; }
								out += `${line}\n`; 
							});
							out += `\n--- HOUSE RULERS ---\n`;
							for (const [house, info] of Object.entries(res.house_rulers)) { out += `- ${house}: ${info}\n`; }
							out += `\n--- HOUSE SIGN DISTRIBUTIONS ---\n`;
							for (const [house, segments] of Object.entries(res.house_sign_distributions)) {
								out += `${house}:\n`;
								if (segments && segments.length > 0) {
									segments.forEach(seg => { out += `      - ${seg}\n`; });
								}
							}
						} else {
							out += `\n- (House Rulers, House Distributions, and some additional points require a known birth time and are not displayed.)\n`;
						}
			
						if (res.tropical_major_positions && res.tropical_major_positions.length > 0) {
							out += `\n\n\n=== TROPICAL CHART ===\n\n`;
							out += `-- CHART ANALYSIS --\n`;
							out += `- Dominant Sign: ${res.tropical_chart_analysis.dominant_sign}\n`;
							out += `- Dominant Element: ${res.tropical_chart_analysis.dominant_element}\n`;
							out += `- Dominant Modality: ${res.tropical_chart_analysis.dominant_modality}\n`;
							out += `- Dominant Planet: ${res.tropical_chart_analysis.dominant_planet}\n\n`;
							out += `--- MAJOR POSITIONS ---\n`;
							res.tropical_major_positions.forEach(p => {
								let line = `- ${p.name}: ${p.position}`;
								if (!['Ascendant', 'Descendant', 'Midheaven (MC)', 'Imum Coeli (IC)', 'South Node'].includes(p.name)) {
									line += ` (${p.percentage}%)`;
								}
								if (p.retrograde) { line += " (Rx)"; }
								if (p.house_info) { line += ` ${p.house_info}`; }
								out += `${line}\n`;
							});
			
							if (res.tropical_retrogrades && res.tropical_retrogrades.length > 0) {
								out += `\n--- RETROGRADE PLANETS (Energy turned inward) ---\n`;
								res.tropical_retrogrades.forEach(p => {
									out += `- ${p.name}\n`;
								});
							}
			
							out += `\n--- MAJOR ASPECTS (ranked by influence score) ---\n`;
							res.tropical_aspects.forEach(a => { out += `- ${a.p1_name} ${a.type} ${a.p2_name} (orb ${a.orb}, score ${a.score})\n`; });
							out += `\n--- ASPECT PATTERNS ---\n`;
							(res.tropical_aspect_patterns && res.tropical_aspect_patterns.length > 0) ? res.tropical_aspect_patterns.forEach(p => { out += `- ${p}\n`; }) : out += "- No major aspect patterns detected.\n";
							if (!res.unknown_time) {
								out += `\n--- ADDITIONAL POINTS & ANGLES ---\n`;
								res.tropical_additional_points.forEach(p => { 
									let line = `- ${p.name}: ${p.info}`;
									if (p.retrograde) { line += " (Rx)"; }
									out += `${line}\n`; 
								});
							}
						}
						this.outputEl.innerText = out;
					},
					
					drawChartWheel(data) {
						const svg = this.wheelSvg;
						svg.innerHTML = ''; 
			
						const centerX = 500, centerY = 500;
						const zodiacRadius = 450, houseRingRadius = 350, innerRadius = 150;
						
						const ascendant = data.sidereal_major_positions.find(p => p.name === 'Ascendant');
						if (!ascendant || ascendant.degrees === null) {
							svg.innerHTML = '<text x="500" y="500" class="house-number">Chart wheel requires a known birth time.</text>';
							return;
						}
						
						const rotation = 180 - ascendant.degrees;
			
						const mainGroup = document.createElementNS(this.SVG_NS, 'g');
						mainGroup.setAttribute('transform', `rotate(${rotation} ${centerX} ${centerY})`);
						svg.appendChild(mainGroup);
			
						const degreeToCartesian = (radius, angleDegrees) => {
							const angleRadians = angleDegrees * (Math.PI / 180);
							return { x: centerX + radius * Math.cos(angleRadians), y: centerY - radius * Math.sin(angleRadians) };
						};
			
						if (data.sidereal_aspects) {
							data.sidereal_aspects.forEach(aspect => {
								if (aspect.p1_degrees === null || aspect.p2_degrees === null) return;
								const p1Coords = degreeToCartesian(innerRadius, aspect.p1_degrees);
								const p2Coords = degreeToCartesian(innerRadius, aspect.p2_degrees);
								const line = document.createElementNS(this.SVG_NS, 'line');
								line.setAttribute('x1', p1Coords.x); line.setAttribute('y1', p1Coords.y);
								line.setAttribute('x2', p2Coords.x); line.setAttribute('y2', p2Coords.y);
								const aspectClass = aspect.type.toLowerCase().replace(' ', '-');
								line.setAttribute('class', `aspect-line aspect-${aspectClass}`);
								mainGroup.appendChild(line);
							});
						}
			
						[zodiacRadius, houseRingRadius, innerRadius].forEach(r => {
							const circle = document.createElementNS(this.SVG_NS, 'circle');
							circle.setAttribute('cx', centerX); circle.setAttribute('cy', centerY);
							circle.setAttribute('r', r); circle.setAttribute('class', 'wheel-circle');
							mainGroup.appendChild(circle);
						});
						
						if (data.true_sidereal_signs) {
							const glyphRadius = houseRingRadius + (zodiacRadius - houseRingRadius) / 2;
							data.true_sidereal_signs.forEach(sign => {
								const [name, start, end] = sign;
								const p1 = degreeToCartesian(houseRingRadius, start);
								const p2 = degreeToCartesian(zodiacRadius, start);
								const line = document.createElementNS(this.SVG_NS, 'line');
								line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
								line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
								line.setAttribute('class', 'zodiac-divider');
								mainGroup.appendChild(line);
			
								const midAngle = start + ((end - start + 360) % 360) / 2;
								const textCoords = degreeToCartesian(glyphRadius, midAngle);
								const text = document.createElementNS(this.SVG_NS, 'text');
								text.setAttribute('x', textCoords.x); text.setAttribute('y', textCoords.y);
								text.setAttribute('class', 'zodiac-glyph');
								text.setAttribute('transform', `rotate(${-rotation} ${textCoords.x} ${textCoords.y})`);
								text.textContent = this.ZODIAC_GLYPHS[name];
								mainGroup.appendChild(text);
							});
						}
			
						if (data.house_cusps && data.house_cusps.length === 12) {
							data.house_cusps.forEach((cuspDegrees, i) => {
								const p1 = degreeToCartesian(innerRadius, cuspDegrees);
								const p2 = degreeToCartesian(houseRingRadius, cuspDegrees);
								const line = document.createElementNS(this.SVG_NS, 'line');
								line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
								line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
								line.setAttribute('class', (i % 3 === 0) ? 'house-cusp major' : 'house-cusp');
								mainGroup.appendChild(line);
							});
							for (let i = 0; i < 12; i++) {
								const startAngle = data.house_cusps[i];
								const endAngle = data.house_cusps[(i + 1) % 12];
								let midAngle = (startAngle + endAngle) / 2;
								if (endAngle < startAngle) midAngle = ((startAngle + endAngle + 360) / 2) % 360;
								const textCoords = degreeToCartesian(innerRadius + 25, midAngle);
								const text = document.createElementNS(this.SVG_NS, 'text');
								text.setAttribute('x', textCoords.x); text.setAttribute('y', textCoords.y);
								text.setAttribute('class', 'house-number');
								text.setAttribute('transform', `rotate(${-rotation} ${textCoords.x} ${textCoords.y})`);
								text.textContent = i + 1;
								mainGroup.appendChild(text);
							}
						}
						
						if (data.sidereal_major_positions) {
							const outerGlyphRadius = zodiacRadius + 35;
							const glyphConnectorRadius = zodiacRadius;
							const minGlyphSeparation = 8;
			
							let planets = data.sidereal_major_positions
								.filter(p => p.degrees !== null && this.PLANET_GLYPHS[p.name])
								.sort((a, b) => a.degrees - b.degrees);
			
							if (planets.length > 0) {
								planets.forEach(p => p.adjustedDegrees = p.degrees);
								for (let k = 0; k < 2; k++) {
									let last = planets[planets.length - 1];
									let first = planets[0];
									let angleDiffWrap = (first.adjustedDegrees + 360) - last.adjustedDegrees;
									if (angleDiffWrap < minGlyphSeparation) {
										let adjustment = (minGlyphSeparation - angleDiffWrap) / 2;
										first.adjustedDegrees += adjustment;
										last.adjustedDegrees -= adjustment;
									}
									for (let i = 1; i < planets.length; i++) {
										let prev = planets[i-1];
										let current = planets[i];
										let angleDiff = current.adjustedDegrees - prev.adjustedDegrees;
										if (angleDiff < minGlyphSeparation) {
											let adjustment = (minGlyphSeparation - angleDiff) / 2;
											prev.adjustedDegrees -= adjustment;
											current.adjustedDegrees += adjustment;
										}
									}
								}
							}
			
							planets.forEach(planet => {
								const lineStartCoords = degreeToCartesian(glyphConnectorRadius, planet.degrees);
								const lineEndCoords = degreeToCartesian(outerGlyphRadius, planet.adjustedDegrees);
								const line = document.createElementNS(this.SVG_NS, 'line');
								line.setAttribute('x1', lineStartCoords.x); line.setAttribute('y1', lineStartCoords.y);
								line.setAttribute('x2', lineEndCoords.x); line.setAttribute('y2', lineEndCoords.y);
								line.setAttribute('class', 'zodiac-divider');
								mainGroup.appendChild(line);
			
								const textCoords = degreeToCartesian(outerGlyphRadius + 20, planet.adjustedDegrees);
								const text = document.createElementNS(this.SVG_NS, 'text');
								text.setAttribute('x', textCoords.x); text.setAttribute('y', textCoords.y);
								text.setAttribute('class', 'planet-glyph');
								text.setAttribute('transform', `rotate(${-rotation} ${textCoords.x} ${textCoords.y})`);
								text.textContent = this.PLANET_GLYPHS[planet.name];
								mainGroup.appendChild(text);
			
								if (planet.retrograde) {
									const rxCoords = degreeToCartesian(outerGlyphRadius + 22, planet.adjustedDegrees + 4.5);
									const rxText = document.createElementNS(this.SVG_NS, 'text');
									rxText.setAttribute('x', rxCoords.x); rxText.setAttribute('y', rxCoords.y);
									rxText.setAttribute('class', 'planet-retrograde');
									rxText.setAttribute('transform', `rotate(${-rotation} ${rxCoords.x} ${rxCoords.y})`);
									rxText.textContent = '℞';
									mainGroup.appendChild(rxText);
								}
							});
						}
					},
					
					populateGlyphLegend() {
						let legendText = '--- ZODIAC SIGNS ---\n';
						for (const [name, glyph] of Object.entries(this.ZODIAC_GLYPHS)) {
							legendText += `${glyph} - ${name}\n`;
						}
						legendText += '\n--- PLANETS & POINTS ---\n';
						for (const [name, glyph] of Object.entries(this.PLANET_GLYPHS)) {
							legendText += `${glyph} - ${name}\n`;
						}
						this.legendEl.innerText = legendText;
					}
				};
			
				document.addEventListener('DOMContentLoaded', () => {
					AstrologyCalculator.init();
				});
			</script>
	</body>
</html>
