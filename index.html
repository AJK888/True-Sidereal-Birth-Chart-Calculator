<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthesis Astrology</title>
    </head>
<body>
    <div class="container">
        </div>

    <script>
    const AstrologyCalculator = {
        // ... (all other properties and methods remain the same) ...
        
        drawChartWheel(data) {
            const svg = this.wheelSvg;
            svg.innerHTML = ''; 

            const centerX = 500, centerY = 500;
            const zodiacRadius = 450, houseRingRadius = 350, planetGlyphRadius = 320, innerRadius = 150;
            
            const ascendant = data.sidereal_major_positions.find(p => p.name === 'Ascendant');
            if (!ascendant || ascendant.degrees === null) {
                svg.innerHTML = '<text x="500" y="500" class="house-number">Chart wheel requires a known birth time.</text>';
                return;
            }
            
            // FIX: This calculation correctly rotates the wheel so the Ascendant
            // is always at the 9 o'clock position (180 degrees on the circle).
            const rotation = 180 - ascendant.degrees;

            const mainGroup = document.createElementNS(this.SVG_NS, 'g');
            mainGroup.setAttribute('transform', `rotate(${rotation} ${centerX} ${centerY})`);
            svg.appendChild(mainGroup);

            const degreeToCartesian = (radius, angleDegrees) => {
                const angleRadians = angleDegrees * (Math.PI / 180);
                return { x: centerX + radius * Math.cos(angleRadians), y: centerY + radius * Math.sin(angleRadians) };
            };

            // Draw Aspects
            if (data.sidereal_aspects) {
                data.sidereal_aspects.forEach(aspect => {
                    if (aspect.p1_degrees === null || aspect.p2_degrees === null) return;
                    const p1Coords = degreeToCartesian(innerRadius, aspect.p1_degrees);
                    const p2Coords = degreeToCartesian(innerRadius, aspect.p2_degrees);
                    const line = document.createElementNS(this.SVG_NS, 'line');
                    line.setAttribute('x1', p1Coords.x); line.setAttribute('y1', p1Coords.y);
                    line.setAttribute('x2', p2Coords.x); line.setAttribute('y2', p2Coords.y);
                    const aspectClass = aspect.type.toLowerCase().replace(' ', '-');
                    line.setAttribute('class', `aspect-line aspect-${aspectClass}`);
                    mainGroup.appendChild(line);
                });
            }

            // Draw Circles
            [zodiacRadius, houseRingRadius, innerRadius].forEach(r => {
                const circle = document.createElementNS(this.SVG_NS, 'circle');
                circle.setAttribute('cx', centerX); circle.setAttribute('cy', centerY);
                circle.setAttribute('r', r); circle.setAttribute('class', 'wheel-circle');
                svg.appendChild(circle);
            });
            
            // Draw Zodiac Signs & Dividers
            if (data.true_sidereal_signs) {
                const glyphRadius = houseRingRadius + (zodiacRadius - houseRingRadius) / 2;
                data.true_sidereal_signs.forEach(sign => {
                    const [name, start, end] = sign;
                    const p1 = degreeToCartesian(houseRingRadius, start);
                    const p2 = degreeToCartesian(zodiacRadius, start);
                    const line = document.createElementNS(this.SVG_NS, 'line');
                    line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
                    line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
                    line.setAttribute('class', 'zodiac-divider');
                    mainGroup.appendChild(line);

                    const midAngle = start + ((end - start + 360) % 360) / 2;
                    const textCoords = degreeToCartesian(glyphRadius, midAngle);
                    const text = document.createElementNS(this.SVG_NS, 'text');
                    text.setAttribute('x', textCoords.x); text.setAttribute('y', textCoords.y);
                    text.setAttribute('class', 'zodiac-glyph');
                    text.setAttribute('transform', `rotate(${-rotation} ${textCoords.x} ${textCoords.y})`);
                    text.textContent = this.ZODIAC_GLYPHS[name];
                    mainGroup.appendChild(text);
                });
            }

            // Draw House Cusps & Numbers
            if (data.house_cusps && data.house_cusps.length === 12) {
                data.house_cusps.forEach((cuspDegrees, i) => {
                    const p1 = degreeToCartesian(innerRadius, cuspDegrees);
                    const p2 = degreeToCartesian(houseRingRadius, cuspDegrees);
                    const line = document.createElementNS(this.SVG_NS, 'line');
                    line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
                    line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
                    line.setAttribute('class', (i % 3 === 0) ? 'house-cusp major' : 'house-cusp');
                    mainGroup.appendChild(line);
                });
                for (let i = 0; i < 12; i++) {
                    const startAngle = data.house_cusps[i];
                    const endAngle = data.house_cusps[(i + 1) % 12];
                    let midAngle = (startAngle + endAngle) / 2;
                    if (endAngle < startAngle) midAngle = ((startAngle + endAngle + 360) / 2) % 360;
                    const textCoords = degreeToCartesian(innerRadius + 25, midAngle);
                    const text = document.createElementNS(this.SVG_NS, 'text');
                    text.setAttribute('x', textCoords.x); text.setAttribute('y', textCoords.y);
                    text.setAttribute('class', 'house-number');
                    text.setAttribute('transform', `rotate(${-rotation} ${textCoords.x} ${textCoords.y})`);
                    text.textContent = i + 1;
                    mainGroup.appendChild(text);
                }
            }
            
            // Draw Planets
            if (data.sidereal_major_positions) {
                data.sidereal_major_positions.forEach(planet => {
                    if (planet.degrees === null || !this.PLANET_GLYPHS[planet.name]) return;
                    const textCoords = degreeToCartesian(planetGlyphRadius, planet.degrees);
                    const text = document.createElementNS(this.SVG_NS, 'text');
                    text.setAttribute('x', textCoords.x); text.setAttribute('y', textCoords.y);
                    text.setAttribute('class', 'planet-glyph');
                    text.setAttribute('transform', `rotate(${-rotation} ${textCoords.x} ${textCoords.y})`);
                    text.textContent = this.PLANET_GLYPHS[planet.name];
                    mainGroup.appendChild(text);
                    if (planet.retrograde) {
                        const rxCoords = degreeToCartesian(planetGlyphRadius + 2, planet.degrees - 4.5);
                        const rxText = document.createElementNS(this.SVG_NS, 'text');
                        rxText.setAttribute('x', rxCoords.x); rxText.setAttribute('y', rxCoords.y);
                        rxText.setAttribute('class', 'planet-retrograde');
                        rxText.setAttribute('transform', `rotate(${-rotation} ${rxCoords.x} ${rxCoords.y})`);
                        rxText.textContent = 'â„ž';
                        mainGroup.appendChild(rxText);
                    }
                });
            }
        },
        
        // ... (all other javascript functions remain the same) ...
    };

    document.addEventListener('DOMContentLoaded', () => {
        AstrologyCalculator.init();
    });
    </script>
</body>
</html>
